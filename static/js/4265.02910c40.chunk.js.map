{"version":3,"file":"static/js/4265.02910c40.chunk.js","mappings":"yHAAA,w1/D","sources":["../../node_modules/code-example/txt/sample.c.txt"],"sourcesContent":["export default \"// Copyright (c) Microsoft. All rights reserved.\\n// Licensed under the MIT license. See LICENSE file in the project root for full\\n// license information.\\n\\n/*\\n *  COMMAND LINE: -Ox -Gz -YX -UPROTOTYPES_REQUIRED\\n */\\n\\n#pragma warning(disable : 4532)\\n#pragma warning(disable : 4702)\\n\\n#if defined(_WIN32)\\n\\n#if defined(_M_SH)\\n#define WIN_CE\\n#endif\\n\\n#if defined(_M_AMD64)\\n#define NEST_IN_FINALLY /* allow when __try nested in __finally OK */\\n#endif\\n\\n#define NTSTATUS LONG\\n#define EXCEPTION_NESTED_CALL 0x10\\n#define RtlRaiseStatus(x) RaiseException((x), 0, 0, NULL)\\n#define RtlRaiseException(x)                                                   \\\\\\n  RaiseException((x)->ExceptionCode, (x)->ExceptionFlags,                      \\\\\\n                 (x)->NumberParameters, (x)->ExceptionInformation)\\n#define IN\\n#define OUT\\n#if !(defined(_M_IA64) || defined(_M_ALPHA) || defined(_M_PPC) ||              \\\\\\n      defined(_M_AMD64) || defined(_M_ARM) || defined(_M_ARM64))\\n#define i386 1\\n#endif\\n#define try __try\\n#define except __except\\n#define finally __finally\\n#define leave __leave\\n\\n#endif\\n\\n#define WIN32_LEAN_AND_MEAN\\n\\n#include \\\"stdio.h\\\"\\n#if defined(_M_IA64) || defined(_M_ALPHA) || defined(_M_PPC) ||                \\\\\\n    defined(_M_AMD64) || defined(_M_ARM) || defined(_M_ARM64)\\n#include \\\"setjmpex.h\\\"\\n#else\\n#include \\\"setjmp.h\\\"\\n#endif\\n#include \\\"float.h\\\"\\n#include \\\"windows.h\\\"\\n#include \\\"math.h\\\"\\n\\n#if !defined(STATUS_SUCCESS)\\n#define STATUS_SUCCESS 0\\n#endif\\n#if !defined(STATUS_UNSUCCESSFUL)\\n#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)\\n#endif\\n\\n//\\n// Define switch constants.\\n//\\n\\n#define BLUE 0\\n#define RED 1\\n\\n//\\n// Define function prototypes.\\n//\\n\\nVOID addtwo(IN LONG First, IN LONG Second, IN PLONG Place);\\n\\nVOID bar1(IN NTSTATUS Status, IN PLONG Counter);\\n\\nVOID bar2(IN PLONG BlackHole, IN PLONG BadAddress, IN PLONG Counter);\\n\\nVOID dojump(IN jmp_buf JumpBuffer, IN PLONG Counter);\\n\\nLONG Echo(IN LONG Value);\\n\\n#if !defined(WIN_CE) // return through finally not allowed on WinCE\\nVOID eret(IN NTSTATUS Status, IN PLONG Counter);\\n#endif\\n\\nVOID except1(IN PLONG Counter);\\n\\nULONG\\nexcept2(IN PEXCEPTION_POINTERS ExceptionPointers, IN PLONG Counter);\\n\\nULONG\\nexcept3(IN PEXCEPTION_POINTERS ExceptionPointers, IN PLONG Counter);\\n\\nVOID foo1(IN NTSTATUS Status);\\n\\nVOID foo2(IN PLONG BlackHole, IN PLONG BadAddress);\\n\\n#if !defined(WIN_CE) // return from finally not allowed on WinCE\\nVOID fret(IN PLONG Counter);\\n#endif\\n\\nBOOLEAN\\nTkm(VOID);\\n\\nVOID Test61Part2(IN OUT PULONG Counter);\\n\\ndouble SquareDouble(IN double op);\\n\\nDECLSPEC_NOINLINE\\nULONG\\nPgFilter(VOID)\\n\\n{\\n\\n  printf(\\\"filter entered...\\\");\\n  return EXCEPTION_EXECUTE_HANDLER;\\n}\\n\\n#pragma warning(push)\\n#pragma warning(disable : 4532)\\n\\nVOID PgTest69(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      *Fault += 1;\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 1) {\\n          *State += 1;\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 1) == 1) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\\n    if (*State != 2) {\\n      *Fault += 1;\\n    }\\n  }\\n\\n  return;\\n}\\n\\nVOID PgTest70(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      *Fault += 1;\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 2) {\\n          PgFilter();\\n          return;\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 2) == 2) ? EXCEPTION_EXECUTE_HANDLER\\n                              : EXCEPTION_CONTINUE_SEARCH) {\\n    *Fault += 1;\\n  }\\n\\n  return;\\n}\\n\\nVOID PgTest71(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      try {\\n        *Fault += 1;\\n      }\\n      finally {\\n        if (AbnormalTermination()) {\\n          if (*State == 3) {\\n            *State += 3;\\n            return;\\n\\n          } else {\\n            *Fault += 1;\\n          }\\n        }\\n      }\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 6) {\\n          *State += 3;\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 3) == 3) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\\n    *Fault += 1;\\n  }\\n\\n  return;\\n}\\n\\nVOID PgTest72(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      try {\\n        *Fault += 1;\\n      }\\n      finally {\\n        if (AbnormalTermination()) {\\n          if (*State == 4) {\\n            *State += 4;\\n            return;\\n\\n          } else {\\n            *Fault += 1;\\n          }\\n        }\\n      }\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 8) {\\n          *State += 4;\\n          PgFilter();\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 4) == 4) ? EXCEPTION_EXECUTE_HANDLER\\n                              : EXCEPTION_CONTINUE_SEARCH) {\\n    *Fault += 1;\\n  }\\n\\n  return;\\n}\\n\\nVOID PgTest73(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      try {\\n        *Fault += 1;\\n      }\\n      finally {\\n        if (AbnormalTermination()) {\\n          if (*State == 5) {\\n            *State += 5;\\n\\n          } else {\\n            *Fault += 1;\\n          }\\n        }\\n      }\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 10) {\\n          *State += 5;\\n          return;\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 5) == 5) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\\n    *Fault += 1;\\n  }\\n\\n  return;\\n}\\n\\nVOID PgTest74(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      try {\\n        *Fault += 1;\\n      }\\n      finally {\\n        if (AbnormalTermination()) {\\n          if (*State == 6) {\\n            *State += 6;\\n\\n          } else {\\n            *Fault += 1;\\n          }\\n        }\\n      }\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 12) {\\n          *State += 6;\\n          PgFilter();\\n          return;\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 6) == 6) ? EXCEPTION_EXECUTE_HANDLER\\n                              : EXCEPTION_CONTINUE_SEARCH) {\\n    *Fault += 1;\\n  }\\n\\n  return;\\n}\\n\\nVOID PgTest75(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      try {\\n        try {\\n          *Fault += 1;\\n        }\\n        finally {\\n          if (AbnormalTermination()) {\\n            if (*State == 7) {\\n              *State += 7;\\n              *Fault += 1;\\n\\n            } else {\\n              *State += 10;\\n            }\\n          }\\n        }\\n      }\\n      except(((*State += 7) == 7) ? EXCEPTION_EXECUTE_HANDLER\\n                                  : EXCEPTION_CONTINUE_SEARCH) {\\n        *Fault += 1;\\n      }\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 28) {\\n          *State += 7;\\n          return;\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 7) == 28) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\\n    *Fault += 1;\\n  }\\n\\n  return;\\n}\\n\\nVOID PgTest76(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      try {\\n        try {\\n          *Fault += 1;\\n        }\\n        finally {\\n          if (AbnormalTermination()) {\\n            if (*State == 8) {\\n              *State += 8;\\n              *Fault += 1;\\n\\n            } else {\\n              *State += 10;\\n            }\\n          }\\n        }\\n      }\\n      except(((*State += 8) == 8) ? EXCEPTION_EXECUTE_HANDLER\\n                                  : EXCEPTION_CONTINUE_SEARCH) {\\n        *Fault += 1;\\n      }\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 32) {\\n          *State += 8;\\n          PgFilter();\\n          return;\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 8) == 32) ? EXCEPTION_EXECUTE_HANDLER\\n                               : EXCEPTION_CONTINUE_SEARCH) {\\n    *Fault += 1;\\n  }\\n\\n  return;\\n}\\n\\nVOID PgTest77(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      try {\\n        try {\\n          *Fault += 1;\\n        }\\n        finally {\\n          if (AbnormalTermination()) {\\n            if (*State == 9) {\\n              *State += 9;\\n              *Fault += 1;\\n\\n            } else {\\n              *State += 10;\\n            }\\n          }\\n        }\\n      }\\n      except(((*State += 9) == 9) ? PgFilter() : EXCEPTION_CONTINUE_SEARCH) {\\n        *Fault += 1;\\n      }\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 36) {\\n          *State += 9;\\n          return;\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 9) == 36) ? EXCEPTION_EXECUTE_HANDLER\\n                               : EXCEPTION_CONTINUE_SEARCH) {\\n    *Fault += 1;\\n  }\\n\\n  return;\\n}\\n\\nVOID PgTest78(IN PLONG State, IN PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      try {\\n        try {\\n          *Fault += 1;\\n        }\\n        finally {\\n          if (AbnormalTermination()) {\\n            if (*State == 10) {\\n              *State += 10;\\n              PgFilter();\\n              *Fault += 1;\\n\\n            } else {\\n              *State += 10;\\n            }\\n          }\\n        }\\n      }\\n      except(((*State += 10) == 10) ? EXCEPTION_EXECUTE_HANDLER\\n                                    : EXCEPTION_CONTINUE_SEARCH) {\\n        *Fault += 1;\\n      }\\n    }\\n    finally {\\n      if (AbnormalTermination()) {\\n        if (*State == 40) {\\n          *State += 10;\\n          return;\\n\\n        } else {\\n          *Fault += 1;\\n        }\\n      }\\n    }\\n  }\\n  except(((*State += 10) == 40) ? EXCEPTION_EXECUTE_HANDLER\\n                                : EXCEPTION_CONTINUE_SEARCH) {\\n    *Fault += 1;\\n  }\\n\\n  return;\\n}\\n\\n#pragma warning(pop)\\n\\nVOID Test79(PLONG Counter, PLONG Fault)\\n\\n{\\n\\n  try {\\n    try {\\n      try {\\n        *Fault += 1;\\n      }\\n      finally {\\n        printf(\\\"finally 1...\\\");\\n        *Fault += 1;\\n      }\\n    }\\n    finally { printf(\\\"finally 2...\\\"); }\\n  }\\n  except(*Counter += 1, printf(\\\"filter 1...\\\"), EXCEPTION_CONTINUE_SEARCH) {}\\n\\n  return;\\n}\\n\\nULONG G;\\n\\nULONG\\nTest80(VOID)\\n\\n{\\n\\n  G = 1;\\n  try {\\n    while (G) {\\n      try {\\n        if (G == 10) {\\n          return 1;\\n        }\\n\\n        if (G == 1) {\\n          continue;\\n        }\\n      }\\n      finally { G = 0; }\\n    }\\n  }\\n  finally { G = 10; }\\n\\n  return 0;\\n}\\n\\nvoid Test81(int *pCounter) {\\n  volatile char *AvPtr = NULL;\\n\\n  __try {\\n    __try { *AvPtr = '\\\\0'; }\\n    __except(EXCEPTION_EXECUTE_HANDLER) { __leave; }\\n  }\\n  __finally {\\n    printf(\\\"in finally \\\");\\n    *pCounter += 1;\\n  }\\n  return;\\n}\\n\\nDECLSPEC_NOINLINE\\nVOID Test82Foo(VOID)\\n\\n{\\n  *(volatile int *)0 = 0;\\n}\\n\\nVOID Test82(__inout PLONG Counter)\\n\\n{\\n\\n  int retval = 1;\\n\\n  __try {\\n    __try { Test82Foo(); }\\n    __finally {\\n      switch (*Counter) {\\n      case 0:\\n        printf(\\\"something failed!\\\\n\\\");\\n        retval = 6;\\n        break;\\n\\n      case 1:\\n        retval = 0;\\n        break;\\n\\n      case 2:\\n        printf(\\\"how did you get here?\\\\n\\\");\\n        retval = 2;\\n        break;\\n\\n      case 3:\\n        printf(\\\"what?!?\\\\n\\\");\\n        retval = 3;\\n        break;\\n\\n      case 4:\\n        printf(\\\"not correct\\\\n\\\");\\n        retval = 4;\\n        break;\\n\\n      case 5:\\n        printf(\\\"error!\\\\n\\\");\\n        retval = 5;\\n        break;\\n      }\\n    }\\n  }\\n  __except(1){}\\n\\n  *Counter = retval;\\n  return;\\n}\\n\\nLONG Test83(VOID)\\n\\n{\\n\\n  G = 1;\\n  try {\\n    try {\\n      while (G) {\\n        try {\\n          if (G == 10) {\\n            return 1;\\n          }\\n\\n          if (G == 1) {\\n            continue;\\n          }\\n        }\\n        finally { G = 0; }\\n      }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { leave; }\\n  }\\n  finally { G = 10; }\\n\\n  return 0;\\n}\\n\\nDECLSPEC_NOINLINE\\nVOID Test84(_Inout_ PLONG Counter)\\n\\n{\\n  volatile int *Fault = 0;\\n\\n  try {\\n    try {\\n      *Fault += 1;\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) {\\n      try {\\n        return;\\n      }\\n      finally { *Counter += 1; }\\n    }\\n  }\\n  finally {\\n\\n    if (AbnormalTermination()) {\\n      *Counter += 1;\\n    }\\n  }\\n\\n  return;\\n}\\n\\nDECLSPEC_NOINLINE\\nLONG Test85(_Inout_ PLONG Counter)\\n\\n{\\n  volatile int *Fault = 0;\\n\\n  G = 1;\\n  try {\\n    try {\\n      try {\\n        while (G) {\\n          try {\\n            try {\\n              if (G == 10) {\\n                return 1;\\n              }\\n              try {\\n                *Counter += 1;\\n              }\\n              except(EXCEPTION_EXECUTE_HANDLER) {}\\n\\n              if (G == 1) {\\n                continue;\\n              }\\n            }\\n            finally {\\n              G = 0;\\n              *Counter += 1;\\n              *Fault += 1;\\n            }\\n          }\\n          except(EXCEPTION_EXECUTE_HANDLER) {\\n            *Counter += 1;\\n            leave;\\n          }\\n        }\\n      }\\n      finally {\\n        G = 10;\\n        *Counter += 1;\\n        *Fault += 1;\\n      }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { *Counter += 1; }\\n    *Counter += 1;\\n  }\\n  finally { *Counter += 1; }\\n  return 1;\\n}\\n\\nDECLSPEC_NOINLINE\\nVOID Test86(_Inout_ PLONG Counter)\\n\\n{\\n  volatile int *Fault = 0;\\n\\n  try {\\n    try {\\n      try {\\n        try {\\n          try {\\n            try {\\n              *Fault += 1;\\n            }\\n            except(printf(\\\"Filter1 %d..\\\", *Counter),\\n                   EXCEPTION_EXECUTE_HANDLER) {\\n              try {\\n                printf(\\\"Handler1 %d..\\\", *Counter);\\n                return;\\n              }\\n              finally {\\n                printf(\\\"Finally1 %d..\\\", *Counter);\\n                *Counter += 1;\\n              }\\n            }\\n          }\\n          finally {\\n            printf(\\\"Finally2 %d..\\\", *Counter);\\n            *Counter += 1;\\n          }\\n        }\\n        except(EXCEPTION_EXECUTE_HANDLER) { leave; }\\n      }\\n      finally { *Counter += 1; }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { leave; }\\n  }\\n  finally { *Counter += 1; }\\n\\n  return;\\n}\\n\\nVOID Test87(_Inout_ PLONG Counter)\\n\\n/*++\\n\\nRoutine Description:\\n\\n    This function verifies the behavior of nested exception dispatching.\\n\\nArguments:\\n\\n    Counter - Supplies a pointer to the state counter.\\n\\nReturn Value:\\n    None.\\n\\n--*/\\n\\n{\\n  volatile int *Fault = 0;\\n\\n//\\n// N.B.  Disabled on x86 due to failing test case with handling of returns\\n//       in nested termination handlers on x86.\\n//\\n//       Disabled on ARM due to failing test case with handling of abutting\\n//       termination handlers within an except handler.\\n//\\n//       Disabled on AMD64 due to failing test case with handling of\\n//       abutting termination handlers within an except handler when a\\n//       non-local goto is involved.\\n//\\n\\n#if !defined(_X86_)\\n  try {\\n    try {\\n      try {\\n        try {\\n          try {\\n            *Fault += 1;\\n\\n            try {\\n            }\\n            finally {\\n              if (AbnormalTermination()) {\\n                *Fault += 1;\\n              }\\n            }\\n          }\\n          finally {\\n\\n            if (AbnormalTermination()) {\\n              if ((*Counter += 13) == 26) {\\n                return;\\n\\n              } else {\\n                *Fault += 1;\\n              }\\n            }\\n          }\\n        }\\n        finally {\\n          if (AbnormalTermination()) {\\n            *Counter += 13;\\n            *Fault += 1;\\n          }\\n        }\\n      }\\n      except(((*Counter += 13) == 13) ? EXCEPTION_EXECUTE_HANDLER\\n                                      : EXCEPTION_CONTINUE_SEARCH) {\\n        *Fault += 1;\\n      }\\n    }\\n    except(((*Counter += 13) == 65) ? EXCEPTION_EXECUTE_HANDLER\\n                                    : EXCEPTION_CONTINUE_SEARCH) {\\n      try {\\n        *Counter += 13;\\n        return;\\n      }\\n      finally {\\n        if (AbnormalTermination()) {\\n          *Counter += 13;\\n          goto Finish;\\n        }\\n      }\\n    }\\n  }\\n  finally {\\n\\n    if (AbnormalTermination()) {\\n      if ((*Counter += 13) == 104) {\\n        goto Finish;\\n      }\\n    }\\n  }\\n\\nFinish:\\n#else\\n  *Counter = 104;\\n#endif\\n\\n  return;\\n}\\n\\nVOID Test88(_Inout_ PLONG Counter)\\n\\n{\\n  volatile int *Fault = 0;\\n\\n  try {\\n    try {\\n      try {\\n        try {\\n          try {\\n            try {\\n              try {\\n                try {\\n                  *Fault += 1;\\n                }\\n                except(((*Counter += 1) == 1) ? *Fault\\n                                              : EXCEPTION_CONTINUE_SEARCH) {}\\n              }\\n              except(*Counter += 1, EXCEPTION_EXECUTE_HANDLER) { *Fault += 2; }\\n            }\\n            except(*Counter += 1, EXCEPTION_CONTINUE_SEARCH) { leave; }\\n          }\\n          except(*Counter += 1, EXCEPTION_CONTINUE_SEARCH) { leave; }\\n        }\\n        except(EXCEPTION_EXECUTE_HANDLER) {}\\n      }\\n      except(EXCEPTION_EXECUTE_HANDLER) {}\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { leave; }\\n  }\\n  finally { *Counter += 1; }\\n}\\n\\nint main(int argc, char *argv[])\\n\\n{\\n\\n  PLONG BadAddress;\\n  PCHAR BadByte;\\n  PLONG BlackHole;\\n  ULONG Index1;\\n  ULONG Index2 = RED;\\n  jmp_buf JumpBuffer;\\n  LONG Counter;\\n  EXCEPTION_RECORD ExceptionRecord;\\n  double doubleresult;\\n\\n  //\\n  // Announce start of exception test.\\n  //\\n\\n  printf(\\\"Start of exception test\\\\n\\\");\\n\\n  //\\n  // Initialize exception record.\\n  //\\n\\n  ExceptionRecord.ExceptionCode = STATUS_INTEGER_OVERFLOW;\\n  ExceptionRecord.ExceptionFlags = 0;\\n  ExceptionRecord.ExceptionRecord = NULL;\\n  ExceptionRecord.NumberParameters = 0;\\n\\n  //\\n  // Initialize pointers.\\n  //\\n\\n  BadAddress = (PLONG)NULL;\\n  BadByte = (PCHAR)NULL;\\n  BadByte += 1;\\n  BlackHole = &Counter;\\n\\n  //\\n  // Simply try statement with a finally clause that is entered sequentially.\\n  //\\n\\n  printf(\\\"    test1...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n  }\\n  finally {\\n    if (abnormal_termination() == FALSE) {\\n      Counter += 1;\\n    }\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simple try statement with an exception clause that is never executed\\n  // because there is no exception raised in the try clause.\\n  //\\n\\n  printf(\\\"    test2...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n  }\\n  except(Counter) { Counter += 1; }\\n\\n  if (Counter != 1) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simple try statement with an exception handler that is never executed\\n  // because the exception expression continues execution.\\n  //\\n\\n  printf(\\\"    test3...\\\");\\n  Counter = 0;\\n  try {\\n    Counter -= 1;\\n    RtlRaiseException(&ExceptionRecord);\\n  }\\n  except(Counter) { Counter -= 1; }\\n\\n  if (Counter != -1) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simple try statement with an exception clause that is always executed.\\n  //\\n\\n  printf(\\\"    test4...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n  }\\n  except(Counter) { Counter += 1; }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simple try statement with an exception clause that is always executed.\\n  //\\n\\n  printf(\\\"    test5...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    *BlackHole += *BadAddress;\\n  }\\n  except(Counter) { Counter += 1; }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simply try statement with a finally clause that is entered as the\\n  // result of an exception.\\n  //\\n\\n  printf(\\\"    test6...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      Counter += 1;\\n      RtlRaiseException(&ExceptionRecord);\\n    }\\n    finally {\\n      if (abnormal_termination() != FALSE) {\\n        Counter += 1;\\n      }\\n    }\\n  }\\n  except(Counter) {\\n    if (Counter == 2) {\\n      Counter += 1;\\n    }\\n  }\\n\\n  if (Counter != 3) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simply try statement with a finally clause that is entered as the\\n  // result of an exception.\\n  //\\n\\n  printf(\\\"    test7...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      Counter += 1;\\n      *BlackHole += *BadAddress;\\n    }\\n    finally {\\n      if (abnormal_termination() != FALSE) {\\n        Counter += 1;\\n      }\\n    }\\n  }\\n  except(Counter) {\\n    if (Counter == 2) {\\n      Counter += 1;\\n    }\\n  }\\n\\n  if (Counter != 3) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simple try that calls a function which raises an exception.\\n  //\\n\\n  printf(\\\"    test8...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    foo1(STATUS_ACCESS_VIOLATION);\\n  }\\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\\n             ? EXCEPTION_EXECUTE_HANDLER\\n             : EXCEPTION_CONTINUE_SEARCH) {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simple try that calls a function which raises an exception.\\n  //\\n\\n  printf(\\\"    test9...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    foo2(BlackHole, BadAddress);\\n  }\\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\\n             ? EXCEPTION_EXECUTE_HANDLER\\n             : EXCEPTION_CONTINUE_SEARCH) {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simple try that calls a function which calls a function that\\n  // raises an exception. The first function has a finally clause\\n  // that must be executed for this test to work.\\n  //\\n\\n  printf(\\\"    test10...\\\");\\n  Counter = 0;\\n  try {\\n    bar1(STATUS_ACCESS_VIOLATION, &Counter);\\n  }\\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\\n             ? EXCEPTION_EXECUTE_HANDLER\\n             : EXCEPTION_CONTINUE_SEARCH) {\\n    Counter -= 1;\\n  }\\n\\n  if (Counter != 98) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simple try that calls a function which calls a function that\\n  // raises an exception. The first function has a finally clause\\n  // that must be executed for this test to work.\\n  //\\n\\n  printf(\\\"    test11...\\\");\\n  Counter = 0;\\n  try {\\n    bar2(BlackHole, BadAddress, &Counter);\\n  }\\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\\n             ? EXCEPTION_EXECUTE_HANDLER\\n             : EXCEPTION_CONTINUE_SEARCH) {\\n    Counter -= 1;\\n  }\\n\\n  if (Counter != 98) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A try within an except\\n  //\\n\\n  printf(\\\"    test12...\\\");\\n  Counter = 0;\\n  try {\\n    foo1(STATUS_ACCESS_VIOLATION);\\n  }\\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\\n             ? EXCEPTION_EXECUTE_HANDLER\\n             : EXCEPTION_CONTINUE_SEARCH) {\\n    Counter += 1;\\n    try {\\n      foo1(STATUS_SUCCESS);\\n    }\\n    except((GetExceptionCode() == STATUS_SUCCESS) ? EXCEPTION_EXECUTE_HANDLER\\n                                                  : EXCEPTION_CONTINUE_SEARCH) {\\n      if (Counter != 1) {\\n        printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n      } else {\\n        printf(\\\"succeeded...\\\");\\n      }\\n\\n      Counter += 1;\\n    }\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A try within an except\\n  //\\n\\n  printf(\\\"    test13...\\\");\\n  Counter = 0;\\n  try {\\n    foo2(BlackHole, BadAddress);\\n  }\\n  except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\\n             ? EXCEPTION_EXECUTE_HANDLER\\n             : EXCEPTION_CONTINUE_SEARCH) {\\n    Counter += 1;\\n    try {\\n      foo1(STATUS_SUCCESS);\\n    }\\n    except((GetExceptionCode() == STATUS_SUCCESS) ? EXCEPTION_EXECUTE_HANDLER\\n                                                  : EXCEPTION_CONTINUE_SEARCH) {\\n      if (Counter != 1) {\\n        printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n      } else {\\n        printf(\\\"succeeded...\\\");\\n      }\\n\\n      Counter += 1;\\n    }\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#if !defined(WIN_CE) // gotos from except/finally not allowed on WinCE\\n  //\\n  // A goto from an exception clause that needs to pass\\n  // through a finally\\n  //\\n\\n  printf(\\\"    test14...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      foo1(STATUS_ACCESS_VIOLATION);\\n    }\\n    except((GetExceptionCode() == STATUS_ACCESS_VIOLATION)\\n               ? EXCEPTION_EXECUTE_HANDLER\\n               : EXCEPTION_CONTINUE_SEARCH) {\\n      Counter += 1;\\n      goto t9;\\n    }\\n  }\\n  finally { Counter += 1; }\\n\\nt9:\\n  ;\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A goto from an finally clause that needs to pass\\n  // through a finally\\n  //\\n\\n  printf(\\\"    test15...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      Counter += 1;\\n    }\\n    finally {\\n      Counter += 1;\\n      goto t10;\\n    }\\n  }\\n  finally { Counter += 1; }\\n\\nt10:\\n  ;\\n  if (Counter != 3) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A goto from an exception clause that needs to pass\\n  // through a finally into the outer finally clause.\\n  //\\n\\n  printf(\\\"    test16...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      try {\\n        Counter += 1;\\n        foo1(STATUS_INTEGER_OVERFLOW);\\n      }\\n      except(EXCEPTION_EXECUTE_HANDLER) {\\n        Counter += 1;\\n        goto t11;\\n      }\\n    }\\n    finally { Counter += 1; }\\n  t11:\\n    ;\\n  }\\n  finally { Counter += 1; }\\n\\n  if (Counter != 4) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A goto from an finally clause that needs to pass\\n  // through a finally into the outer finally clause.\\n  //\\n\\n  printf(\\\"    test17...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      Counter += 1;\\n    }\\n    finally {\\n      Counter += 1;\\n      goto t12;\\n    }\\n  t12:\\n    ;\\n  }\\n  finally { Counter += 1; }\\n\\n  if (Counter != 3) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A return from an except clause\\n  //\\n\\n  printf(\\\"    test18...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    eret(STATUS_ACCESS_VIOLATION, &Counter);\\n  }\\n  finally { Counter += 1; }\\n\\n  if (Counter != 4) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A return from a finally clause\\n  //\\n\\n  printf(\\\"    test19...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    fret(&Counter);\\n  }\\n  finally { Counter += 1; }\\n\\n  if (Counter != 5) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif\\n\\n  //\\n  // A simple set jump followed by a long jump.\\n  //\\n\\n  printf(\\\"    test20...\\\");\\n  Counter = 0;\\n  if (setjmp(JumpBuffer) == 0) {\\n    Counter += 1;\\n    longjmp(JumpBuffer, 1);\\n\\n  } else {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A set jump followed by a long jump out of a finally clause that is\\n  // sequentially executed.\\n  //\\n\\n  printf(\\\"    test21...\\\");\\n  Counter = 0;\\n  if (setjmp(JumpBuffer) == 0) {\\n    try {\\n      Counter += 1;\\n    }\\n    finally {\\n      Counter += 1;\\n      longjmp(JumpBuffer, 1);\\n    }\\n\\n  } else {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 3) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A set jump within a try clause followed by a long jump out of a\\n  // finally clause that is sequentially executed.\\n  //\\n\\n  printf(\\\"    test22...\\\");\\n  Counter = 0;\\n  try {\\n    if (setjmp(JumpBuffer) == 0) {\\n      Counter += 1;\\n\\n    } else {\\n      Counter += 1;\\n    }\\n  }\\n  finally {\\n    Counter += 1;\\n    if (Counter == 2) {\\n      Counter += 1;\\n      longjmp(JumpBuffer, 1);\\n    }\\n  }\\n\\n  if (Counter != 5) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A set jump followed by a try/except, followed by a try/finally where\\n  // the try body of the try/finally raises an exception that is handled\\n  // by the try/excecpt which causes the try/finally to do a long jump out\\n  // of a finally clause. This will create a collided unwind.\\n  //\\n\\n  printf(\\\"    test23...\\\");\\n  Counter = 0;\\n  if (setjmp(JumpBuffer) == 0) {\\n    try {\\n      try {\\n        Counter += 1;\\n        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n      }\\n      finally {\\n        Counter += 1;\\n        longjmp(JumpBuffer, 1);\\n      }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\\n\\n  } else {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 3) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A set jump followed by a try/except, followed by a several nested\\n  // try/finally's where the inner try body of the try/finally raises an\\n  // exception that is handled by the try/except which causes the\\n  // try/finally to do a long jump out of a finally clause. This will\\n  // create a collided unwind.\\n  //\\n\\n  printf(\\\"    test24...\\\");\\n  Counter = 0;\\n  if (setjmp(JumpBuffer) == 0) {\\n    try {\\n      try {\\n        try {\\n          try {\\n            Counter += 1;\\n            RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n          }\\n          finally { Counter += 1; }\\n        }\\n        finally {\\n          Counter += 1;\\n          longjmp(JumpBuffer, 1);\\n        }\\n      }\\n      finally { Counter += 1; }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\\n\\n  } else {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 5) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A set jump followed by a try/except, followed by a try/finally which\\n  // calls a subroutine which contains a try finally that raises an\\n  // exception that is handled to the try/except.\\n  //\\n\\n  printf(\\\"    test25...\\\");\\n  Counter = 0;\\n  if (setjmp(JumpBuffer) == 0) {\\n    try {\\n      try {\\n        try {\\n          Counter += 1;\\n          dojump(JumpBuffer, &Counter);\\n        }\\n        finally { Counter += 1; }\\n      }\\n      finally { Counter += 1; }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\\n\\n  } else {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 7) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A set jump followed by a try/except, followed by a try/finally which\\n  // calls a subroutine which contains a try finally that raises an\\n  // exception that is handled to the try/except.\\n  //\\n\\n  printf(\\\"    test26...\\\");\\n  Counter = 0;\\n  if (setjmp(JumpBuffer) == 0) {\\n    try {\\n      try {\\n        try {\\n          try {\\n            Counter += 1;\\n            dojump(JumpBuffer, &Counter);\\n          }\\n          finally { Counter += 1; }\\n        }\\n        finally {\\n          Counter += 1;\\n          longjmp(JumpBuffer, 1);\\n        }\\n      }\\n      finally { Counter += 1; }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\\n\\n  } else {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 8) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Test nested exceptions.\\n  //\\n\\n  printf(\\\"    test27...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      Counter += 1;\\n      except1(&Counter);\\n    }\\n    except(except2(GetExceptionInformation(), &Counter)) { Counter += 2; }\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { Counter += 3; }\\n\\n  if (Counter != 55) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Simple try that causes an integer overflow exception.\\n  //\\n\\n  printf(\\\"    test28...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    addtwo(0x7fff0000, 0x10000, &Counter);\\n  }\\n  except((GetExceptionCode() == STATUS_INTEGER_OVERFLOW)\\n             ? EXCEPTION_EXECUTE_HANDLER\\n             : EXCEPTION_CONTINUE_SEARCH) {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n//\\n// Simple try that raises an misaligned data exception.\\n//\\n#if !defined(i386) && !defined(_M_IA64) && !defined(_M_AMD64) &&               \\\\\\n    !defined(_M_ARM) && !defined(_M_ARM64)\\n  printf(\\\"    test29...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    foo2(BlackHole, (PLONG)BadByte);\\n  }\\n  except((GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT)\\n             ? EXCEPTION_EXECUTE_HANDLER\\n             : EXCEPTION_CONTINUE_SEARCH) {\\n    Counter += 1;\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#endif\\n  //\\n  // Continue from a try body with an exception clause in a loop.\\n  //\\n\\n  printf(\\\"    test30...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      if ((Index1 & 0x1) == 0) {\\n        continue;\\n\\n      } else {\\n        Counter += 1;\\n      }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 40; }\\n\\n    Counter += 2;\\n  }\\n\\n  if (Counter != 15) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\\n  //\\n  // Continue from a try body with an finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test31...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      if ((Index1 & 0x1) == 0) {\\n        continue;\\n\\n      } else {\\n        Counter += 1;\\n      }\\n    }\\n    finally { Counter += 2; }\\n\\n    Counter += 3;\\n  }\\n\\n  if (Counter != 40) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif\\n\\n  //\\n  // Continue from doubly nested try body with an exception clause in a\\n  // loop.\\n  //\\n\\n  printf(\\\"    test32...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 0) {\\n          continue;\\n\\n        } else {\\n          Counter += 1;\\n        }\\n      }\\n      except(EXCEPTION_EXECUTE_HANDLER) { Counter += 10; }\\n\\n      Counter += 2;\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 20; }\\n\\n    Counter += 3;\\n  }\\n\\n  if (Counter != 30) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\\n  //\\n  // Continue from doubly nested try body with an finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test33...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 0) {\\n          continue;\\n\\n        } else {\\n          Counter += 1;\\n        }\\n      }\\n      finally { Counter += 2; }\\n\\n      Counter += 3;\\n    }\\n    finally { Counter += 4; }\\n\\n    Counter += 5;\\n  }\\n\\n  if (Counter != 105) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Continue from a finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test34...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      if ((Index1 & 0x1) == 0) {\\n        Counter += 1;\\n      }\\n    }\\n    finally {\\n      Counter += 2;\\n      continue;\\n    }\\n\\n    Counter += 4;\\n  }\\n\\n  if (Counter != 25) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Continue from a doubly nested finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test35...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 0) {\\n          Counter += 1;\\n        }\\n      }\\n      finally {\\n        Counter += 2;\\n        continue;\\n      }\\n\\n      Counter += 4;\\n    }\\n    finally { Counter += 5; }\\n\\n    Counter += 6;\\n  }\\n\\n  if (Counter != 75) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Continue from a doubly nested finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test36...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 0) {\\n          Counter += 1;\\n        }\\n      }\\n      finally { Counter += 2; }\\n\\n      Counter += 4;\\n    }\\n    finally {\\n      Counter += 5;\\n      continue;\\n    }\\n\\n    Counter += 6;\\n  }\\n\\n  if (Counter != 115) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif\\n\\n  //\\n  // Break from a try body with an exception clause in a loop.\\n  //\\n\\n  printf(\\\"    test37...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      if ((Index1 & 0x1) == 1) {\\n        break;\\n\\n      } else {\\n        Counter += 1;\\n      }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 40; }\\n\\n    Counter += 2;\\n  }\\n\\n  if (Counter != 3) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\\n  //\\n  // Break from a try body with an finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test38...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      if ((Index1 & 0x1) == 1) {\\n        break;\\n\\n      } else {\\n        Counter += 1;\\n      }\\n    }\\n    finally { Counter += 2; }\\n\\n    Counter += 3;\\n  }\\n\\n  if (Counter != 8) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif\\n\\n  //\\n  // Break from doubly nested try body with an exception clause in a\\n  // loop.\\n  //\\n\\n  printf(\\\"    test39...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 1) {\\n          break;\\n\\n        } else {\\n          Counter += 1;\\n        }\\n      }\\n      except(EXCEPTION_EXECUTE_HANDLER) { Counter += 10; }\\n\\n      Counter += 2;\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 20; }\\n\\n    Counter += 3;\\n  }\\n\\n  if (Counter != 6) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\\n  //\\n  // Break from doubly nested try body with an finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test40...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 1) {\\n          break;\\n\\n        } else {\\n          Counter += 1;\\n        }\\n      }\\n      finally { Counter += 2; }\\n\\n      Counter += 3;\\n    }\\n    finally { Counter += 4; }\\n\\n    Counter += 5;\\n  }\\n\\n  if (Counter != 21) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Break from a finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test41...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      if ((Index1 & 0x1) == 1) {\\n        Counter += 1;\\n      }\\n    }\\n    finally {\\n      Counter += 2;\\n      break;\\n    }\\n\\n    Counter += 4;\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Break from a doubly nested finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test42...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 1) {\\n          Counter += 1;\\n        }\\n      }\\n      finally {\\n        Counter += 2;\\n        break;\\n      }\\n\\n      Counter += 4;\\n    }\\n    finally { Counter += 5; }\\n\\n    Counter += 6;\\n  }\\n\\n  if (Counter != 7) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Break from a doubly nested finally clause in a loop.\\n  //\\n\\n  printf(\\\"    test43...\\\");\\n  Counter = 0;\\n  for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 1) {\\n          Counter += 1;\\n        }\\n      }\\n      finally { Counter += 2; }\\n\\n      Counter += 4;\\n    }\\n    finally {\\n      Counter += 5;\\n      break;\\n    }\\n\\n    Counter += 6;\\n  }\\n\\n  if (Counter != 11) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif\\n\\n  //\\n  // Break from a try body with an exception clause in a switch.\\n  //\\n\\n  printf(\\\"    test44...\\\");\\n  Counter = 0;\\n  Index1 = 1;\\n  switch (Index2) {\\n  case BLUE:\\n    Counter += 100;\\n    break;\\n\\n  case RED:\\n    try {\\n      if ((Index1 & 0x1) == 1) {\\n        break;\\n\\n      } else {\\n        Counter += 1;\\n      }\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 40; }\\n\\n    Counter += 2;\\n    break;\\n  }\\n\\n  if (Counter != 0) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\\n  //\\n  // Break from a try body with an finally clause in a switch.\\n  //\\n\\n  printf(\\\"    test45...\\\");\\n  Counter = 0;\\n  Index1 = 1;\\n  switch (Index2) {\\n  case BLUE:\\n    Counter += 100;\\n    break;\\n\\n  case RED:\\n    try {\\n      if ((Index1 & 0x1) == 1) {\\n        break;\\n\\n      } else {\\n        Counter += 1;\\n      }\\n    }\\n    finally { Counter += 2; }\\n\\n    Counter += 3;\\n  }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif\\n\\n  //\\n  // Break from doubly nested try body with an exception clause in a\\n  // switch.\\n  //\\n\\n  printf(\\\"    test46...\\\");\\n  Counter = 0;\\n  Index1 = 1;\\n  switch (Index2) {\\n  case BLUE:\\n    Counter += 100;\\n    break;\\n\\n  case RED:\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 1) {\\n          break;\\n\\n        } else {\\n          Counter += 1;\\n        }\\n      }\\n      except(EXCEPTION_EXECUTE_HANDLER) { Counter += 10; }\\n\\n      Counter += 2;\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { Counter += 20; }\\n\\n    Counter += 3;\\n  }\\n\\n  if (Counter != 0) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#if !defined(WIN_CE) // gotos from try/finally not allowed on WinCE\\n  //\\n  // Break from doubly nested try body with an finally clause in a switch.\\n  //\\n\\n  printf(\\\"    test47...\\\");\\n  Counter = 0;\\n  Index1 = 1;\\n  switch (Index2) {\\n  case BLUE:\\n    Counter += 100;\\n    break;\\n\\n  case RED:\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 1) {\\n          break;\\n\\n        } else {\\n          Counter += 1;\\n        }\\n      }\\n      finally { Counter += 2; }\\n\\n      Counter += 3;\\n    }\\n    finally { Counter += 4; }\\n\\n    Counter += 5;\\n  }\\n\\n  if (Counter != 6) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Break from a finally clause in a switch.\\n  //\\n\\n  printf(\\\"    test48...\\\");\\n  Counter = 0;\\n  Index1 = 1;\\n  switch (Index2) {\\n  case BLUE:\\n    Counter += 100;\\n    break;\\n\\n  case RED:\\n    try {\\n      if ((Index1 & 0x1) == 1) {\\n        Counter += 1;\\n      }\\n    }\\n    finally {\\n      Counter += 2;\\n      break;\\n    }\\n\\n    Counter += 4;\\n  }\\n\\n  if (Counter != 3) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Break from a doubly nested finally clause in a switch.\\n  //\\n\\n  printf(\\\"    test49...\\\");\\n  Counter = 0;\\n  Index1 = 1;\\n  switch (Index2) {\\n  case BLUE:\\n    Counter += 100;\\n    break;\\n\\n  case RED:\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 1) {\\n          Counter += 1;\\n        }\\n      }\\n      finally {\\n        Counter += 2;\\n        break;\\n      }\\n\\n      Counter += 4;\\n    }\\n    finally { Counter += 5; }\\n\\n    Counter += 6;\\n  }\\n\\n  if (Counter != 8) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Break from a doubly nested finally clause in a switch.\\n  //\\n\\n  printf(\\\"    test50...\\\");\\n  Counter = 0;\\n  Index1 = 1;\\n  switch (Index2) {\\n  case BLUE:\\n    Counter += 100;\\n    break;\\n\\n  case RED:\\n    try {\\n      try {\\n        if ((Index1 & 0x1) == 1) {\\n          Counter += 1;\\n        }\\n      }\\n      finally { Counter += 2; }\\n\\n      Counter += 4;\\n    }\\n    finally {\\n      Counter += 5;\\n      break;\\n    }\\n\\n    Counter += 6;\\n  }\\n\\n  if (Counter != 12) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif\\n\\n  //\\n  // Leave from an if in a simple try/finally.\\n  //\\n\\n  printf(\\\"    test51...\\\");\\n  Counter = 0;\\n  try {\\n    if (Echo(Counter) == Counter) {\\n      Counter += 3;\\n      leave;\\n\\n    } else {\\n      Counter += 100;\\n    }\\n  }\\n  finally {\\n    if (abnormal_termination() == FALSE) {\\n      Counter += 5;\\n    }\\n  }\\n\\n  if (Counter != 8) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Leave from a loop in a simple try/finally.\\n  //\\n\\n  printf(\\\"    test52...\\\");\\n  Counter = 0;\\n  try {\\n    for (Index1 = 0; Index1 < 10; Index1 += 1) {\\n      if (Echo(Index1) == Index1) {\\n        Counter += 3;\\n        leave;\\n      }\\n\\n      Counter += 100;\\n    }\\n  }\\n  finally {\\n    if (abnormal_termination() == FALSE) {\\n      Counter += 5;\\n    }\\n  }\\n\\n  if (Counter != 8) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Leave from a switch in a simple try/finally.\\n  //\\n\\n  printf(\\\"    test53...\\\");\\n  Counter = 0;\\n  try {\\n    switch (Index2) {\\n    case BLUE:\\n      break;\\n\\n    case RED:\\n      Counter += 3;\\n      leave;\\n    }\\n\\n    Counter += 100;\\n  }\\n  finally {\\n    if (abnormal_termination() == FALSE) {\\n      Counter += 5;\\n    }\\n  }\\n\\n  if (Counter != 8) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Leave from an if in doubly nested try/finally followed by a leave\\n  // from an if in the outer try/finally.\\n  //\\n\\n  printf(\\\"    test54...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      if (Echo(Counter) == Counter) {\\n        Counter += 3;\\n        leave;\\n\\n      } else {\\n        Counter += 100;\\n      }\\n    }\\n    finally {\\n      if (abnormal_termination() == FALSE) {\\n        Counter += 5;\\n      }\\n    }\\n\\n    if (Echo(Counter) == Counter) {\\n      Counter += 3;\\n      leave;\\n\\n    } else {\\n      Counter += 100;\\n    }\\n  }\\n  finally {\\n    if (abnormal_termination() == FALSE) {\\n      Counter += 5;\\n    }\\n  }\\n\\n  if (Counter != 16) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#if !defined(WIN_CE) // leave from finally not allowed on WinCE\\n  //\\n  // Leave from an if in doubly nested try/finally followed by a leave\\n  // from the finally of the outer try/finally.\\n  //\\n\\n  printf(\\\"    test55...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      if (Echo(Counter) == Counter) {\\n        Counter += 3;\\n        leave;\\n\\n      } else {\\n        Counter += 100;\\n      }\\n    }\\n    finally {\\n      if (abnormal_termination() == FALSE) {\\n        Counter += 5;\\n        leave;\\n      }\\n    }\\n\\n    Counter += 100;\\n  }\\n  finally {\\n    if (abnormal_termination() == FALSE) {\\n      Counter += 5;\\n    }\\n  }\\n\\n  if (Counter != 13) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif\\n\\n  //\\n  // Try/finally within the except clause of a try/except that is always\\n  // executed.\\n  //\\n\\n  printf(\\\"    test56...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n  }\\n  except(Counter) {\\n    try {\\n      Counter += 3;\\n    }\\n    finally {\\n      if (abnormal_termination() == FALSE) {\\n        Counter += 5;\\n      }\\n    }\\n  }\\n\\n  if (Counter != 9) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Try/finally within the finally clause of a try/finally.\\n  //\\n\\n  printf(\\\"    test57...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n  }\\n  finally {\\n    if (abnormal_termination() == FALSE) {\\n      try {\\n        Counter += 3;\\n      }\\n      finally {\\n        if (abnormal_termination() == FALSE) {\\n          Counter += 5;\\n        }\\n      }\\n    }\\n  }\\n\\n  if (Counter != 9) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Try/except within the finally clause of a try/finally.\\n  //\\n\\n  printf(\\\"    test58...\\\");\\n#if !defined(NEST_IN_FINALLY)\\n  printf(\\\"skipped\\\\n\\\");\\n#else\\n  Counter = 0;\\n  try {\\n    Counter -= 1;\\n  }\\n  finally {\\n    try {\\n      Counter += 2;\\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n    }\\n    except(Counter) {\\n      try {\\n        Counter += 3;\\n      }\\n      finally {\\n        if (abnormal_termination() == FALSE) {\\n          Counter += 5;\\n        }\\n      }\\n    }\\n  }\\n\\n  if (Counter != 9) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif /* def(NEST_IN_FINALLY) */\\n\\n  //\\n  // Try/except within the except clause of a try/except that is always\\n  // executed.\\n  //\\n\\n  printf(\\\"    test59...\\\");\\n  Counter = 0;\\n  try {\\n    Counter += 1;\\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n  }\\n  except(Counter) {\\n    try {\\n      Counter += 3;\\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n    }\\n    except(Counter - 3) { Counter += 5; }\\n  }\\n\\n  if (Counter != 9) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Try with a Try which exits the scope with a goto\\n  //\\n\\n  printf(\\\"    test60...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      goto outside;\\n    }\\n    except(1) { Counter += 1; }\\n\\n  outside:\\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n  }\\n  except(1) { Counter += 3; }\\n\\n  if (Counter != 3) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Try/except which gets an exception from a subfunction within\\n  // a try/finally which has a try/except in the finally clause\\n  //\\n\\n  printf(\\\"    test61...\\\");\\n#if !defined(NEST_IN_FINALLY)\\n  printf(\\\"skipped\\\\n\\\");\\n#else\\n  Counter = 0;\\n  try {\\n    Test61Part2(&Counter);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { Counter += 11; }\\n\\n  if (Counter != 24) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n#endif /* def(NEST_IN_FINALLY) */\\n\\n  //\\n  // Check for precision of exception on floating point\\n  //\\n\\n  printf(\\\"    test62...\\\");\\n\\n#if defined(i386) || defined(_M_IA64) || defined(_M_ALPHA) || defined(_M_AMD64)\\n\\n/* enable floating point overflow */\\n#if defined(i386)\\n  _control87(_control87(0, 0) & ~EM_OVERFLOW, _MCW_EM);\\n#else\\n  //\\n  // use portable version of _control87\\n  //\\n  _controlfp(_controlfp(0, 0) & ~EM_OVERFLOW, _MCW_EM);\\n#endif\\n\\n  Counter = 0;\\n  try {\\n    doubleresult = SquareDouble(1.7e300);\\n\\n    try {\\n      doubleresult = SquareDouble(1.0);\\n    }\\n    except(1) { Counter += 3; }\\n  }\\n  except(1) { Counter += 1; }\\n\\n  if (Counter != 1) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n/* clear up pending unmasked exceptions and restore FP control registers */\\n#if defined(i386)\\n  _clear87();\\n  _control87(_control87(0, 0) | EM_OVERFLOW, 0xfffff);\\n#else\\n  _clearfp();\\n  _controlfp(_controlfp(0, 0) | EM_OVERFLOW, 0xfffff);\\n#endif\\n\\n#else\\n  printf(\\\"skipped\\\\n\\\");\\n#endif\\n\\n  //\\n  // A try/finally inside a try/except where an exception is raised in the\\n  // try/finally.\\n  //\\n\\n  printf(\\\"    test63...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      Counter += 1;\\n    }\\n    finally {\\n      Counter += 3;\\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n    }\\n  }\\n  except(1) { Counter += 6; }\\n\\n  if (Counter != 10) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A try/finally inside a try/except where an exception is raised in the\\n  // in the try/except and the try/finally.\\n  //\\n\\n  printf(\\\"    test64...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      Counter += 1;\\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n    }\\n    finally {\\n      Counter += 3;\\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n    }\\n  }\\n  except(1) { Counter += 6; }\\n\\n  if (Counter != 10) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A try/finally inside a try/except where an exception is raised in the\\n  // try/finally.\\n  //\\n\\n  printf(\\\"    test65...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      Counter += 1;\\n    }\\n    finally {\\n      Counter += 3;\\n      *BlackHole += *BadAddress;\\n      Counter += 13;\\n    }\\n  }\\n  except(1) { Counter += 6; }\\n\\n  if (Counter != 10) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A try/finally inside a try/except where an exception is raised in the\\n  // in the try/except and the try/finally.\\n  //\\n\\n  printf(\\\"    test66...\\\");\\n  Counter = 0;\\n  try {\\n    try {\\n      Counter += 1;\\n      *BlackHole += *BadAddress;\\n      Counter += 13;\\n    }\\n    finally {\\n      Counter += 3;\\n      *BlackHole += *BadAddress;\\n      Counter += 13;\\n    }\\n  }\\n  except(1) { Counter += 6; }\\n\\n  if (Counter != 10) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A try/finally inside a try/finally inside a try/except where an\\n  // exception is raised in the in the try/except and in try/finally.\\n  //\\n\\n  printf(\\\"    test67...\\\");\\n  try {\\n    try {\\n      *BlackHole += *BadAddress;\\n    }\\n    finally {\\n      try {\\n        Counter = 0;\\n      }\\n      finally {\\n        if (Counter != 0) {\\n          Counter += 1;\\n        }\\n      }\\n\\n      Counter += 1;\\n      *BlackHole += *BadAddress;\\n    }\\n  }\\n  except(1) { Counter += 1; }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // A try/finally inside a try/finally inside a try/except where an\\n  // exception is raised in the in the try/except and in try/finally.\\n  //\\n\\n  printf(\\\"    test68...\\\");\\n  try {\\n    try {\\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n    }\\n    finally {\\n      try {\\n        Counter = 0;\\n      }\\n      finally {\\n        if (Counter != 0) {\\n          Counter += 1;\\n        }\\n      }\\n\\n      Counter += 1;\\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n    }\\n  }\\n  except(1) { Counter += 1; }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n//\\n// Patch guard test 69.\\n//\\n\\n#if defined(_AMD64_) || defined(_X86_)\\n\\n  printf(\\\"    test69...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest69(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test70...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest70(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 2) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test71...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest71(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 9) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test72...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest72(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 12) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test73...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest73(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 15) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test74...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest74(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 18) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test75...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest75(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 35) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test76...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest76(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 40) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test77...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest77(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 45) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test78...\\\");\\n  Counter = 0;\\n  try {\\n    PgTest78(&Counter, BadAddress);\\n  }\\n  except(EXCEPTION_EXECUTE_HANDLER) { printf(\\\"unexpected exception...\\\"); }\\n\\n  if (Counter != 50) {\\n    printf(\\\"failed, count = %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n#else\\n  printf(\\\"    test69...filter entered...succeeded\\\\n\\\");\\n  printf(\\\"    test70...filter entered...succeeded\\\\n\\\");\\n  printf(\\\"    test71...filter entered...succeeded\\\\n\\\");\\n  printf(\\\"    test72...filter entered...succeeded\\\\n\\\");\\n  printf(\\\"    test73...filter entered...succeeded\\\\n\\\");\\n  printf(\\\"    test74...filter entered...succeeded\\\\n\\\");\\n  printf(\\\"    test75...filter entered...succeeded\\\\n\\\");\\n  printf(\\\"    test76...filter entered...succeeded\\\\n\\\");\\n  printf(\\\"    test77...filter entered...succeeded\\\\n\\\");\\n  printf(\\\"    test78...filter entered...succeeded\\\\n\\\");\\n#endif\\n\\n  if (LOBYTE(LOWORD(GetVersion())) < 6) {\\n    printf(\\\"    test79...\\\");\\n    printf(\\\"filter 1...filter 2...finally 1...filter 1...filter 2...finally \\\"\\n           \\\"2...passed\\\\n\\\");\\n  } else {\\n\\n    printf(\\\"    test79...\\\");\\n    Counter = 0;\\n    try {\\n      Test79(&Counter, BadAddress);\\n    }\\n    except(printf(\\\"filter 2...\\\"), EXCEPTION_EXECUTE_HANDLER) { Counter += 1; }\\n\\n    if (Counter == 3) {\\n      printf(\\\"passed\\\\n\\\");\\n\\n    } else {\\n      printf(\\\"failed  %d \\\\n\\\", Counter);\\n    }\\n  }\\n\\n  printf(\\\"    test80...\\\");\\n  if (Test80() != 0) {\\n    printf(\\\"failed\\\\n\\\");\\n\\n  } else {\\n    printf(\\\"passed\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test81...\\\");\\n  Counter = 0;\\n  Test81(&Counter);\\n  if (Counter != 1) {\\n    printf(\\\"failed  %d \\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"passed\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test82...\\\");\\n  Counter = 1;\\n  Test82(&Counter);\\n  if (Counter != 0) {\\n    printf(\\\"failed\\\\n\\\");\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test83...\\\");\\n  if (Test83() != 0) {\\n    printf(\\\"failed\\\\n\\\");\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test84...\\\");\\n  Counter = 0;\\n  Test84(&Counter);\\n  if (Counter != 2) {\\n    printf(\\\"failed\\\\n\\\");\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test85...\\\");\\n  Counter = 0;\\n  Test85(&Counter);\\n  if (Counter != 7) {\\n    printf(\\\"failed\\\\n\\\");\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test86...\\\");\\n  Counter = 0;\\n  Test86(&Counter);\\n  if (Counter != 4) {\\n    printf(\\\"failed %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test87...\\\");\\n  Counter = 0;\\n  Test87(&Counter);\\n  if (Counter != 104) {\\n    printf(\\\"failed %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  printf(\\\"    test88...\\\");\\n  Counter = 0;\\n  Test88(&Counter);\\n  if (Counter != 6) {\\n    printf(\\\"failed %d\\\\n\\\", Counter);\\n\\n  } else {\\n    printf(\\\"succeeded\\\\n\\\");\\n  }\\n\\n  //\\n  // Announce end of exception test.\\n  //\\n\\n  printf(\\\"End of exception test\\\\n\\\");\\n  return;\\n}\\n\\n#pragma optimize(\\\"a\\\", off)\\nVOID addtwo(long First, long Second, long *Place)\\n\\n{\\n\\n  RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n  *Place = First + Second;\\n  return;\\n}\\n#pragma optimize(\\\"\\\", on)\\n\\nVOID bar1(IN NTSTATUS Status, IN PLONG Counter) {\\n\\n  try {\\n    foo1(Status);\\n  }\\n  finally {\\n    if (abnormal_termination() != FALSE) {\\n      *Counter = 99;\\n\\n    } else {\\n      *Counter = 100;\\n    }\\n  }\\n\\n  return;\\n}\\n\\nVOID bar2(IN PLONG BlackHole, IN PLONG BadAddress, IN PLONG Counter) {\\n\\n  try {\\n    foo2(BlackHole, BadAddress);\\n  }\\n  finally {\\n    if (abnormal_termination() != FALSE) {\\n      *Counter = 99;\\n\\n    } else {\\n      *Counter = 100;\\n    }\\n  }\\n\\n  return;\\n}\\n\\nVOID dojump(IN jmp_buf JumpBuffer, IN PLONG Counter)\\n\\n{\\n\\n  try {\\n    try {\\n      *Counter += 1;\\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n    }\\n    finally { *Counter += 1; }\\n  }\\n  finally {\\n    *Counter += 1;\\n    longjmp(JumpBuffer, 1);\\n  }\\n}\\n\\n#if !defined(WIN_CE) // return through finally not allowed on WinCE\\nVOID eret(IN NTSTATUS Status, IN PLONG Counter)\\n\\n{\\n\\n  try {\\n    try {\\n      foo1(Status);\\n    }\\n    except((GetExceptionCode() == Status) ? EXCEPTION_EXECUTE_HANDLER\\n                                          : EXCEPTION_CONTINUE_SEARCH) {\\n      *Counter += 1;\\n      return;\\n    }\\n  }\\n  finally { *Counter += 1; }\\n\\n  return;\\n}\\n#endif\\n\\nVOID except1(IN PLONG Counter)\\n\\n{\\n\\n  try {\\n    *Counter += 5;\\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n  }\\n  except(except3(GetExceptionInformation(), Counter)) { *Counter += 7; }\\n\\n  *Counter += 9;\\n  return;\\n}\\n\\nULONG\\nexcept2(IN PEXCEPTION_POINTERS ExceptionPointers, IN PLONG Counter)\\n\\n{\\n\\n  PEXCEPTION_RECORD ExceptionRecord;\\n\\n  ExceptionRecord = ExceptionPointers->ExceptionRecord;\\n  if ((ExceptionRecord->ExceptionCode == STATUS_UNSUCCESSFUL) &&\\n      ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) == 0)) {\\n    *Counter += 11;\\n    return EXCEPTION_EXECUTE_HANDLER;\\n\\n  } else {\\n    *Counter += 13;\\n    return EXCEPTION_CONTINUE_SEARCH;\\n  }\\n}\\n\\nULONG\\nexcept3(IN PEXCEPTION_POINTERS ExceptionPointers, IN PLONG Counter)\\n\\n{\\n\\n  PEXCEPTION_RECORD ExceptionRecord;\\n\\n  ExceptionRecord = ExceptionPointers->ExceptionRecord;\\n  if ((ExceptionRecord->ExceptionCode == STATUS_INTEGER_OVERFLOW) &&\\n      ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) == 0)) {\\n    *Counter += 17;\\n    RtlRaiseStatus(STATUS_UNSUCCESSFUL);\\n\\n  } else if ((ExceptionRecord->ExceptionCode == STATUS_UNSUCCESSFUL) &&\\n             ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) != 0)) {\\n    *Counter += 19;\\n    return EXCEPTION_CONTINUE_SEARCH;\\n  }\\n\\n  *Counter += 23;\\n  return EXCEPTION_EXECUTE_HANDLER;\\n}\\n\\nVOID foo1(IN NTSTATUS Status)\\n\\n{\\n\\n  //\\n  // Raise exception.\\n  //\\n\\n  RtlRaiseStatus(Status);\\n  return;\\n}\\n\\nVOID foo2(IN PLONG BlackHole, IN PLONG BadAddress)\\n\\n{\\n\\n  //\\n  // Raise exception.\\n  //\\n\\n  *BlackHole += *BadAddress;\\n  return;\\n}\\n\\n#if !defined(WIN_CE) // return from finally not allowed on WinCE\\nVOID fret(IN PLONG Counter)\\n\\n{\\n\\n  try {\\n    try {\\n      *Counter += 1;\\n    }\\n    finally {\\n      *Counter += 1;\\n      return;\\n    }\\n  }\\n  finally { *Counter += 1; }\\n\\n  return;\\n}\\n#endif\\n\\nLONG Echo(IN LONG Value)\\n\\n{\\n  return Value;\\n}\\n\\n#if defined(NEST_IN_FINALLY)\\nVOID Test61Part2(IN OUT PULONG Counter) {\\n  try {\\n    *Counter -= 1;\\n    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n  }\\n  finally {\\n    try {\\n      *Counter += 2;\\n      RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);\\n    }\\n    except(EXCEPTION_EXECUTE_HANDLER) { *Counter += 5; }\\n    *Counter += 7;\\n  }\\n}\\n#endif /* def(NEST_IN_FINALLY) */\\n\\ndouble SquareDouble(IN double op) {\\n  return exp(2.0 * log(op));\\n}\\n\";"],"names":[],"sourceRoot":""}