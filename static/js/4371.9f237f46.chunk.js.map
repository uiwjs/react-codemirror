{"version":3,"file":"static/js/4371.9f237f46.chunk.js","mappings":"yHAAA,mlE","sources":["../../node_modules/code-example/txt/sample.elixir.txt"],"sourcesContent":["export default \"# Elixir is a dynamic, functional language for building scalable\\n# and maintainable applications. Learn more: https://elixir-lang.org\\n\\n\\\"Elixir\\\" |> String.graphemes() |> Enum.frequencies()\\n#=> %{\\\"E\\\" => 1, \\\"i\\\" => 2, \\\"l\\\" => 1, \\\"r\\\" => 1, \\\"x\\\" => 1}\\n\\n\\n### Scalability ###\\n\\n# All Elixir code runs inside lightweight threads of execution (called processes)\\n# that are isolated and exchange information via messages:\\n\\ncurrent_process = self()\\n\\n# Spawn an Elixir process (not an operating system one!)\\nspawn_link(fn ->\\n  send(current_process, {:msg, \\\"hello world\\\"})\\nend)\\n\\n# Block until the message is received\\nreceive do\\n  {:msg, contents} -> IO.puts(contents)\\nend\\n\\n\\n### Fault-tolerance ###\\n\\n# To cope with failures, Elixir provides supervisors which describe\\n# how to restart parts of your system when things go awry, going back\\n# to a known initial state that is guaranteed to work:\\n\\nchildren = [\\n  TCP.Pool,\\n  {TCP.Acceptor, port: 4040}\\n]\\n\\nSupervisor.start_link(children, strategy: :one_for_one)\\n\\n\\n### Functional programming ###\\n\\n# Functional programming promotes a coding style that helps\\n# developers write code that is short, concise, and maintainable.\\n# One prominent example is pattern matching:\\n\\n%User{name: name, age: age} = User.get(\\\"John Doe\\\")\\nname #=> \\\"John Doe\\\"\\n\\n# When mixed with guards, pattern matching allows us to elegantly\\n# match and assert specific conditions for some code to execute:\\n\\ndef drive(%User{age: age}) when age >= 16 do\\n  # Code that drives a car\\nend\\n\\ndrive(User.get(\\\"John Doe\\\"))\\n#=> Fails if the user is under 16\\n\\n\\n### Extensibility and DSLs ###\\n\\n# Elixir has been designed to be extensible, letting developers\\n# naturally extend the language to particular domains,\\n# in order to increase their productivity.\\n\\ndefmodule MathTest do\\n  use ExUnit.Case, async: true\\n\\n  test \\\"can add two numbers\\\" do\\n    assert 1 + 1 == 2\\n  end\\nend\\n\\n\\n### Erlang compatible ###\\n\\n# An Elixir programmer can invoke any Erlang function with no runtime cost:\\n\\n:crypto.hash(:md5, \\\"Using crypto from Erlang OTP\\\")\\n#=> <<192, 223, 75, 115, ...>>\\n\";"],"names":[],"sourceRoot":""}