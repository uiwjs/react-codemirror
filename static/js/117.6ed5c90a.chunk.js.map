{"version":3,"sources":["../node_modules/codemirror/mode/verilog/verilog.js"],"names":["CodeMirror","defineMode","config","parserConfig","indentUnit","statementIndentUnit","dontAlignCalls","compilerDirectivesUseRegularIndentation","noIndentKeywords","multiLineStrings","hooks","words","str","obj","split","i","length","curPunc","curKeyword","keywords","isOperatorChar","isBracketChar","unsignedNumber","decimalLiteral","binaryLiteral","octLiteral","hexLiteral","realLiteral","closingBracketOrWord","closingBracket","compilerDirectiveRegex","RegExp","compilerDirectiveBeginRegex","compilerDirectiveEndRegex","blockKeywords","openClose","keyword","undefined","statementKeywords","tokenBase","stream","state","style","ch","peek","test","next","eatWhile","cur","current","startsWith","endsWith","keywordClose","substr","eatSpace","withSpace","backUp","tokenize","tokenString","eat","tokenComment","skipToEnd","match","quote","escaped","end","maybeEnd","Context","indented","column","type","scopekind","align","prev","this","pushContext","col","c","context","popContext","t","isClosing","text","contextClosing","closingKeywords","isInsideScopeKind","ctx","buildElectricInputRegEx","allClosings","closings","j","push","join","electricInput","startState","basecolumn","compilerDirectiveIndented","startOfLine","token","sol","indentation","isClosingAssignment","close","indent","textAfter","Pass","fromHook","firstChar","charAt","closing","possibleClosing","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME","name","tlvIdentifierStyle","tlvScopePrefixChars","tlvIndentUnit","tlvTrackStatements","tlvIdentMatch","tlvFirstLevelIndentMatch","tlvLineIndentationMatch","tlvCommentMatch","tlvScopeStyle","depth","tlvIndentationStyle","tlvIdentNext","tlvInBlockComment","string","tlvCodeActive","pos","blankline","chPos","bodyString","slice","statementComment","pop","tlvNextIndent","beginStatement","eol","prefix","mnemonic","hasOwnProperty","mod","require"],"mappings":"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","file":"static/js/117.6ed5c90a.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"verilog\", function(config, parserConfig) {\n\n  var indentUnit = config.indentUnit,\n      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      // compilerDirectivesUseRegularIndentation - If set, Compiler directive\n      // indentation follows the same rules as everything else. Otherwise if\n      // false, compiler directives will track their own indentation.\n      // For example, `ifdef nested inside another `ifndef will be indented,\n      // but a `ifdef inside a function block may not be indented.\n      compilerDirectivesUseRegularIndentation = parserConfig.compilerDirectivesUseRegularIndentation,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n  var keywords = words(\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\n    \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\n    \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\n    \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\n    \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\n    \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\n    \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\n    \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\n    \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\n    \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\n    \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\n    \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\n    \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\n    \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\n    \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\n    \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\n    \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\n    \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n  /** Operators from IEEE 1800-2012\n     unary_operator ::=\n       + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_operator ::=\n       + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n       | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n       | -> | <->\n     inc_or_dec_operator ::= ++ | --\n     unary_module_path_operator ::=\n       ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_module_path_operator ::=\n       == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:<>]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n\n  var closingBracketOrWord = /^((`?\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n  var compilerDirectiveRegex      = new RegExp(\n    \"^(`(?:ifdef|ifndef|elsif|else|endif|undef|undefineall|define|include|begin_keywords|celldefine|default|\" +\n    \"nettype|end_keywords|endcelldefine|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive))\\\\b\");\n  var compilerDirectiveBeginRegex = /^(`(?:ifdef|ifndef|elsif|else))\\b/;\n  var compilerDirectiveEndRegex   = /^(`(?:elsif|else|endif))\\b/;\n\n  var curPunc;\n  var curKeyword;\n\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n  var blockKeywords = words(\n    \"case checker class clocking config function generate interface module package \" +\n    \"primitive program property specify sequence table task\"\n  );\n\n  // Opening/closing pairs\n  var openClose = {};\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"   ] = \"while\";\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n  openClose[\"macro_begin\"] = \"macro_end\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  }\n\n  // Keywords which open statements that are ended with a semi-colon\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while extern typedef\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(), style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\n      return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    }\n    // Macros (tick-defines)\n    if (ch == '`') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        var cur = stream.current();\n        curKeyword = cur;\n        // Macros that end in _begin, are start of block and end with _end\n        if (cur.startsWith(\"`uvm_\") && cur.endsWith(\"_begin\")) {\n          var keywordClose = curKeyword.substr(0,curKeyword.length - 5) + \"end\";\n          openClose[cur] = keywordClose;\n          curPunc = \"newblock\";\n        } else {\n          stream.eatSpace();\n          if (stream.peek() == '(') {\n            // Check if this is a block\n            curPunc = \"newmacro\";\n          }\n          var withSpace = stream.current();\n          // Move the stream back before the spaces\n          stream.backUp(withSpace.length - cur.length);\n        }\n        return \"def\";\n      } else {\n        return null;\n      }\n    }\n    // System calls\n    if (ch == '$') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    }\n    // Time literals\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    }\n    // Event\n    if (ch == '@') {\n      stream.next();\n      stream.eatWhile(/[@]/);\n      return \"def\";\n    }\n    // Strings\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    // Comments\n    if (ch == \"/\") {\n      stream.next();\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      stream.backUp(1);\n    }\n\n    // Numeric literals\n    if (stream.match(realLiteral) ||\n        stream.match(decimalLiteral) ||\n        stream.match(binaryLiteral) ||\n        stream.match(octLiteral) ||\n        stream.match(hexLiteral) ||\n        stream.match(unsignedNumber) ||\n        stream.match(realLiteral)) {\n      return \"number\";\n    }\n\n    // Operators\n    if (stream.eatWhile(isOperatorChar)) {\n      curPunc = stream.current();\n      return \"meta\";\n    }\n\n    // Keywords / plain variables\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n          if (cur === \"fork\") {\n            // Fork can be a statement instead of block in cases of:\n            // \"disable fork;\" and \"wait fork;\" (trailing semicolon)\n            stream.eatSpace()\n            if (stream.peek() == ';') {\n              curPunc = \"newstatement\";\n            }\n            stream.backUp(stream.current().length - cur.length);\n          }\n        }\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n        curKeyword = cur;\n        return \"keyword\";\n      }\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, scopekind, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.scopekind = scopekind;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type, scopekind) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, scopekind ? scopekind : \"\", null, state.context);\n    return state.context = c;\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function isInsideScopeKind(ctx, scopekind) {\n    if (ctx == null) {\n      return false;\n    }\n    if (ctx.scopekind === scopekind) {\n      return true;\n    }\n    return isInsideScopeKind(ctx.prev, scopekind);\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  }\n\n  // Interface\n  return {\n\n    // Regex to force current line to reindent\n    electricInput: buildElectricInputRegEx(),\n\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: null,\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", \"top\", false),\n        indented: 0,\n        compilerDirectiveIndented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n        if (style !== undefined) {\n          return style;\n        }\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") {\n        if (((curPunc === \"=\") || (curPunc === \"<=\")) && !isInsideScopeKind(ctx, \"assignment\")) {\n          // '<=' could be nonblocking assignment or lessthan-equals (which shouldn't cause indent)\n          //      Search through the context to see if we are already in an assignment.\n          // '=' could be inside port declaration with comma or ')' afterward, or inside for(;;) block.\n          pushContext(state, stream.column() + curPunc.length, \"assignment\", \"assignment\");\n          if (ctx.align == null) ctx.align = true;\n        }\n        return style;\n      }\n      if (ctx.align == null) ctx.align = true;\n\n      var isClosingAssignment = ctx.type == \"assignment\" &&\n        closingBracket.test(curPunc) && ctx.prev && ctx.prev.type === curPunc;\n      if (curPunc == ctx.type || isClosingAssignment) {\n        if (isClosingAssignment) {\n          ctx = popContext(state);\n        }\n        ctx = popContext(state);\n        if (curPunc == \")\") {\n          // Handle closing macros, assuming they could have a semicolon or begin/end block inside.\n          if (ctx && (ctx.type === \"macro\")) {\n            ctx = popContext(state);\n            while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n          }\n        } else if (curPunc == \"}\") {\n          // Handle closing statements like constraint block: \"foreach () {}\" which\n          // do not have semicolon at end.\n          if (ctx && (ctx.type === \"statement\")) {\n            while (ctx && (ctx.type == \"statement\")) ctx = popContext(state);\n          }\n        }\n      } else if (((curPunc == \";\" || curPunc == \",\") && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ||\n               (ctx.type && isClosing(curKeyword, ctx.type))) {\n        ctx = popContext(state);\n        while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\", \"case\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\", curKeyword);\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n          // The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n          // Same thing for task\n        } else if (curKeyword == \"class\" && ctx && ctx.type == \"statement\") {\n          // Same thing for class (e.g. typedef)\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close, curKeyword);\n        }\n      } else if (curPunc == \"newmacro\" || (curKeyword && curKeyword.match(compilerDirectiveRegex))) {\n        if (curPunc == \"newmacro\") {\n          // Macros (especially if they have parenthesis) potentially have a semicolon\n          // or complete statement/block inside, and should be treated as such.\n          pushContext(state, stream.column(), \"macro\", \"macro\");\n        }\n        if (curKeyword.match(compilerDirectiveEndRegex)) {\n          state.compilerDirectiveIndented -= statementIndentUnit;\n        }\n        if (curKeyword.match(compilerDirectiveBeginRegex)) {\n          state.compilerDirectiveIndented += statementIndentUnit;\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing)\n        closing = isClosing(possibleClosing[0], ctx.type);\n      if (!compilerDirectivesUseRegularIndentation && textAfter.match(compilerDirectiveRegex)) {\n        if (textAfter.match(compilerDirectiveEndRegex)) {\n          return state.compilerDirectiveIndented - statementIndentUnit;\n        }\n        return state.compilerDirectiveIndented;\n      }\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);\n      else if ((closingBracket.test(ctx.type) || ctx.type == \"assignment\")\n        && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n      else if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;\n      else return ctx.indented + (closing ? 0 : indentUnit);\n    },\n\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\",\n    fold: \"indent\"\n  };\n});\n\n  CodeMirror.defineMIME(\"text/x-verilog\", {\n    name: \"verilog\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-systemverilog\", {\n    name: \"verilog\"\n  });\n\n\n\n  // TL-Verilog mode.\n  // See tl-x.org for language spec.\n  // See the mode in action at makerchip.com.\n  // Contact: steve.hoover@redwoodeda.com\n\n  // TLV Identifier prefixes.\n  // Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n  // are included.\n  var tlvIdentifierStyle = {\n    \"|\": \"link\",\n    \">\": \"property\",  // Should condition this off for > TLV 1c.\n    \"$\": \"variable\",\n    \"$$\": \"variable\",\n    \"?$\": \"qualifier\",\n    \"?*\": \"qualifier\",\n    \"-\": \"hr\",\n    \"/\": \"property\",\n    \"/-\": \"property\",\n    \"@\": \"variable-3\",\n    \"@-\": \"variable-3\",\n    \"@++\": \"variable-3\",\n    \"@+=\": \"variable-3\",\n    \"@+=-\": \"variable-3\",\n    \"@--\": \"variable-3\",\n    \"@-=\": \"variable-3\",\n    \"%+\": \"tag\",\n    \"%-\": \"tag\",\n    \"%\": \"tag\",\n    \">>\": \"tag\",\n    \"<<\": \"tag\",\n    \"<>\": \"tag\",\n    \"#\": \"tag\",  // Need to choose a style for this.\n    \"^\": \"attribute\",\n    \"^^\": \"attribute\",\n    \"^!\": \"attribute\",\n    \"*\": \"variable-2\",\n    \"**\": \"variable-2\",\n    \"\\\\\": \"keyword\",\n    \"\\\"\": \"comment\"\n  };\n\n  // Lines starting with these characters define scope (result in indentation).\n  var tlvScopePrefixChars = {\n    \"/\": \"beh-hier\",\n    \">\": \"beh-hier\",\n    \"-\": \"phys-hier\",\n    \"|\": \"pipe\",\n    \"?\": \"when\",\n    \"@\": \"stage\",\n    \"\\\\\": \"keyword\"\n  };\n  var tlvIndentUnit = 3;\n  var tlvTrackStatements = false;\n  var tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/;  // Matches an identifier.\n  // Note that ':' is excluded, because of it's use in [:].\n  var tlvFirstLevelIndentMatch = /^[! ]  /;\n  var tlvLineIndentationMatch = /^[! ] */;\n  var tlvCommentMatch = /^\\/[\\/\\*]/;\n\n\n  // Returns a style specific to the scope at the given indentation column.\n  // Type is one of: \"indent\", \"scope-ident\", \"before-scope-ident\".\n  function tlvScopeStyle(state, indentation, type) {\n    // Begin scope.\n    var depth = indentation / tlvIndentUnit;  // TODO: Pass this in instead.\n    return \"tlv-\" + state.tlvIndentationStyle[depth] + \"-\" + type;\n  }\n\n  // Return true if the next thing in the stream is an identifier with a mnemonic.\n  function tlvIdentNext(stream) {\n    var match;\n    return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;\n  }\n\n  CodeMirror.defineMIME(\"text/x-tlv\", {\n    name: \"verilog\",\n\n    hooks: {\n\n      electricInput: false,\n\n\n      // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n      // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n      // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n      //   - M4 tokens\n      //   - TLV scope indentation\n      //   - Statement delimitation (enabled by tlvTrackStatements)\n      token: function(stream, state) {\n        var style = undefined;\n        var match;  // Return value of pattern matches.\n\n        // Set highlighting mode based on code region (TLV or SV).\n        if (stream.sol() && ! state.tlvInBlockComment) {\n          // Process region.\n          if (stream.peek() == '\\\\') {\n            style = \"def\";\n            stream.skipToEnd();\n            if (stream.string.match(/\\\\SV/)) {\n              state.tlvCodeActive = false;\n            } else if (stream.string.match(/\\\\TLV/)){\n              state.tlvCodeActive = true;\n            }\n          }\n          // Correct indentation in the face of a line prefix char.\n          if (state.tlvCodeActive && stream.pos == 0 &&\n              (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {\n            state.indented = match[0].length;\n          }\n\n          // Compute indentation state:\n          //   o Auto indentation on next line\n          //   o Indentation scope styles\n          var indented = state.indented;\n          var depth = indented / tlvIndentUnit;\n          if (depth <= state.tlvIndentationStyle.length) {\n            // not deeper than current scope\n\n            var blankline = stream.string.length == indented;\n            var chPos = depth * tlvIndentUnit;\n            if (chPos < stream.string.length) {\n              var bodyString = stream.string.slice(chPos);\n              var ch = bodyString[0];\n              if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&\n                  tlvIdentifierStyle[match[1]])) {\n                // This line begins scope.\n                // Next line gets indented one level.\n                indented += tlvIndentUnit;\n                // Style the next level of indentation (except non-region keyword identifiers,\n                //   which are statements themselves)\n                if (!(ch == \"\\\\\" && chPos > 0)) {\n                  state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n                  if (tlvTrackStatements) {state.statementComment = false;}\n                  depth++;\n                }\n              }\n            }\n            // Clear out deeper indentation levels unless line is blank.\n            if (!blankline) {\n              while (state.tlvIndentationStyle.length > depth) {\n                state.tlvIndentationStyle.pop();\n              }\n            }\n          }\n          // Set next level of indentation.\n          state.tlvNextIndent = indented;\n        }\n\n        if (state.tlvCodeActive) {\n          // Highlight as TLV.\n\n          var beginStatement = false;\n          if (tlvTrackStatements) {\n            // This starts a statement if the position is at the scope level\n            // and we're not within a statement leading comment.\n            beginStatement =\n                   (stream.peek() != \" \") &&   // not a space\n                   (style === undefined) &&    // not a region identifier\n                   !state.tlvInBlockComment && // not in block comment\n                   //!stream.match(tlvCommentMatch, false) && // not comment start\n                   (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level\n            if (beginStatement) {\n              if (state.statementComment) {\n                // statement already started by comment\n                beginStatement = false;\n              }\n              state.statementComment =\n                   stream.match(tlvCommentMatch, false); // comment start\n            }\n          }\n\n          var match;\n          if (style !== undefined) {\n            // Region line.\n            style += \" \" + tlvScopeStyle(state, 0, \"scope-ident\")\n          } else if (((stream.pos / tlvIndentUnit) < state.tlvIndentationStyle.length) &&\n                     (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {\n            // Indentation\n            style = // make this style distinct from the previous one to prevent\n                    // codemirror from combining spans\n                    \"tlv-indent-\" + (((stream.pos % 2) == 0) ? \"even\" : \"odd\") +\n                    // and style it\n                    \" \" + tlvScopeStyle(state, stream.pos - tlvIndentUnit, \"indent\");\n            // Style the line prefix character.\n            if (match[0].charAt(0) == \"!\") {\n              style += \" tlv-alert-line-prefix\";\n            }\n            // Place a class before a scope identifier.\n            if (tlvIdentNext(stream)) {\n              style += \" \" + tlvScopeStyle(state, stream.pos, \"before-scope-ident\");\n            }\n          } else if (state.tlvInBlockComment) {\n            // In a block comment.\n            if (stream.match(/^.*?\\*\\//)) {\n              // Exit block comment.\n              state.tlvInBlockComment = false;\n              if (tlvTrackStatements && !stream.eol()) {\n                // Anything after comment is assumed to be real statement content.\n                state.statementComment = false;\n              }\n            } else {\n              stream.skipToEnd();\n            }\n            style = \"comment\";\n          } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n            // Start comment.\n            if (match[0] == \"//\") {\n              // Line comment.\n              stream.skipToEnd();\n            } else {\n              // Block comment.\n              state.tlvInBlockComment = true;\n            }\n            style = \"comment\";\n          } else if (match = stream.match(tlvIdentMatch)) {\n            // looks like an identifier (or identifier prefix)\n            var prefix = match[1];\n            var mnemonic = match[2];\n            if (// is identifier prefix\n                tlvIdentifierStyle.hasOwnProperty(prefix) &&\n                // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n                (mnemonic.length > 0 || stream.eol())) {\n              style = tlvIdentifierStyle[prefix];\n              if (stream.column() == state.indented) {\n                // Begin scope.\n                style += \" \" + tlvScopeStyle(state, stream.column(), \"scope-ident\")\n              }\n            } else {\n              // Just swallow one character and try again.\n              // This enables subsequent identifier match with preceding symbol character, which\n              //   is legal within a statement.  (E.g., !$reset).  It also enables detection of\n              //   comment start with preceding symbols.\n              stream.backUp(stream.current().length - 1);\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^\\t+/)) {\n            // Highlight tabs, which are illegal.\n            style = \"tlv-tab\";\n          } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n            // [:], (), {}, ;.\n            style = \"meta\";\n          } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n            // m4 pre proc\n            style = (match[1] == \"+\") ? \"tlv-m4-plus\" : \"tlv-m4\";\n          } else if (stream.match(/^ +/)){\n            // Skip over spaces.\n            if (stream.eol()) {\n              // Trailing spaces.\n              style = \"error\";\n            } else {\n              // Non-trailing spaces.\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^[\\w\\d_]+/)) {\n            // alpha-numeric token.\n            style = \"number\";\n          } else {\n            // Eat the next char w/ no formatting.\n            stream.next();\n            style = \"tlv-default\";\n          }\n          if (beginStatement) {\n            style += \" tlv-statement\";\n          }\n        } else {\n          if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n            // m4 pre proc\n            style = \"tlv-m4\";\n          }\n        }\n        return style;\n      },\n\n      indent: function(state) {\n        return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;\n      },\n\n      startState: function(state) {\n        state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.\n        state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).\n        state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.\n        state.tlvInBlockComment = false;  // True inside /**/ comment.\n        if (tlvTrackStatements) {\n          state.statementComment = false;  // True inside a statement's header comment.\n        }\n      }\n\n    }\n  });\n});\n"],"sourceRoot":""}