{"version":3,"file":"static/js/9047.a9237351.chunk.js","mappings":"yHAAA,k7C","sources":["../../node_modules/code-example/txt/sample.hcl.txt"],"sourcesContent":["export default \"terraform {\\n  required_providers {\\n    aws = {\\n      source  = \\\"hashicorp/aws\\\"\\n      version = \\\"~> 1.0.4\\\"\\n    }\\n  }\\n}\\n\\nvariable \\\"aws_region\\\" {}\\n\\nvariable \\\"base_cidr_block\\\" {\\n  description = \\\"A /16 CIDR range definition, such as 10.1.0.0/16, that the VPC will use\\\"\\n  default = \\\"10.1.0.0/16\\\"\\n}\\n\\nvariable \\\"availability_zones\\\" {\\n  description = \\\"A list of availability zones in which to create subnets\\\"\\n  type = list(string)\\n}\\n\\nprovider \\\"aws\\\" {\\n  region = var.aws_region\\n}\\n\\nresource \\\"aws_vpc\\\" \\\"main\\\" {\\n  # Referencing the base_cidr_block variable allows the network address\\n  # to be changed without modifying the configuration.\\n  cidr_block = var.base_cidr_block\\n}\\n\\nresource \\\"aws_subnet\\\" \\\"az\\\" {\\n  # Create one subnet for each given availability zone.\\n  count = length(var.availability_zones)\\n\\n  # For each subnet, use one of the specified availability zones.\\n  availability_zone = var.availability_zones[count.index]\\n\\n  # By referencing the aws_vpc.main object, Terraform knows that the subnet\\n  # must be created only after the VPC is created.\\n  vpc_id = aws_vpc.main.id\\n\\n  # Built-in functions and operators can be used for simple transformations of\\n  # values, such as computing a subnet address. Here we create a /20 prefix for\\n  # each subnet, using consecutive addresses for each availability zone,\\n  # such as 10.1.16.0/20 .\\n  cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index+1)\\n}\\n\";"],"names":[],"sourceRoot":""}