{"version":3,"file":"static/js/5823.a371a8aa.chunk.js","mappings":"yHAAA,81G","sources":["../../node_modules/code-example/txt/sample.scheme.txt"],"sourcesContent":["export default \";;; make-matrix creates a matrix (a vector of vectors).\\n(define make-matrix\\n  (lambda (rows columns)\\n    (do ((m (make-vector rows))\\n         (i 0 (+ i 1)))\\n        ((= i rows) m)\\n        (vector-set! m i (make-vector columns)))))\\n\\n;;; matrix? checks to see if its argument is a matrix.\\n;;; It isn't foolproof, but it's generally good enough.\\n(define matrix?\\n  (lambda (x)\\n    (and (vector? x)\\n         (> (vector-length x) 0)\\n         (vector? (vector-ref x 0)))))\\n\\n;; matrix-rows returns the number of rows in a matrix.\\n(define matrix-rows\\n   (lambda (x)\\n      (vector-length x)))\\n\\n;; matrix-columns returns the number of columns in a matrix.\\n(define matrix-columns\\n   (lambda (x)\\n      (vector-length (vector-ref x 0))))\\n\\n;;; matrix-ref returns the jth element of the ith row.\\n(define matrix-ref\\n  (lambda (m i j)\\n    (vector-ref (vector-ref m i) j)))\\n\\n;;; matrix-set! changes the jth element of the ith row.\\n(define matrix-set!\\n  (lambda (m i j x)\\n    (vector-set! (vector-ref m i) j x)))\\n\\n;;; mul is the generic matrix/scalar multiplication procedure\\n(define mul\\n  (lambda (x y)\\n    ;; mat-sca-mul multiplies a matrix by a scalar.\\n    (define mat-sca-mul\\n       (lambda (m x)\\n          (let* ((nr (matrix-rows m))\\n                 (nc (matrix-columns m))\\n                 (r  (make-matrix nr nc)))\\n             (do ((i 0 (+ i 1)))\\n                 ((= i nr) r)\\n                 (do ((j 0 (+ j 1)))\\n                     ((= j nc))\\n                     (matrix-set! r i j\\n                        (* x (matrix-ref m i j))))))))\\n\\n    ;; mat-mat-mul multiplies one matrix by another, after verifying\\n    ;; that the first matrix has as many columns as the second\\n    ;; matrix has rows.\\n    (define mat-mat-mul\\n       (lambda (m1 m2)\\n          (let* ((nr1 (matrix-rows m1))\\n                 (nr2 (matrix-rows m2))\\n                 (nc2 (matrix-columns m2))\\n                 (r   (make-matrix nr1 nc2)))\\n             (if (not (= (matrix-columns m1) nr2))\\n                 (match-error m1 m2))\\n             (do ((i 0 (+ i 1)))\\n                 ((= i nr1) r)\\n                 (do ((j 0 (+ j 1)))\\n                     ((= j nc2))\\n                     (do ((k 0 (+ k 1))\\n                          (a 0\\n                             (+ a\\n                                (* (matrix-ref m1 i k)\\n                                   (matrix-ref m2 k j)))))\\n                         ((= k nr2)\\n                          (matrix-set! r i j a))))))))\\n\\n   ;; type-error is called to complain when mul receives an invalid\\n   ;; type of argument.\\n    (define type-error\\n       (lambda (what)\\n          (error 'mul\\n             \\\"~s is not a number or matrix\\\"\\n             what)))\\n\\n    ;; match-error is called to complain when mul receives a pair of\\n    ;; incompatible arguments.\\n    (define match-error\\n       (lambda (what1 what2)\\n          (error 'mul\\n             \\\"~s and ~s are incompatible operands\\\"\\n             what1\\n             what2)))\\n\\n    ;; body of mul; dispatch based on input types\\n    (cond\\n      ((number? x)\\n       (cond\\n         ((number? y) (* x y))\\n         ((matrix? y) (mat-sca-mul y x))\\n         (else (type-error y))))\\n      ((matrix? x)\\n       (cond\\n         ((number? y) (mat-sca-mul x y))\\n         ((matrix? y) (mat-mat-mul x y))\\n         (else (type-error y))))\\n      (else (type-error x)))))\";"],"names":[],"sourceRoot":""}